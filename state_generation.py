""" make quantum circuit operators to produce given target unitary vectors

currently only for 3 qbit system
goal is to cover as much as possible of unitary vectors, with rather small circuits
a symbolic operator is created using sympy
the symbolic operator has as variables the angles of various y-rotations
the image of the ground state |000> under the operator is the resulting final state (symbolic_final_state)
goal is hence to create an operator that can cover as much as possible of the 2**3 = 8 
dimensional non-negative unit sphere
a default operator is part of the class

state_function: approximate a given vector with a state that can be produced with the operator
get_state_gen_circuit: take y-rotation angles as input, make a cirq circuit to produce the 
corresponding final state with the operator given by symbolic_operator and the passed y-rotation angles
approx_target_state: take a non-negative target vector, scale to be unit vector and 
find approximation with a state generated by the operator given suitable y-rotation angles

TODO: adding a method to set different operator
"""

import cirq
import numpy as np
import random 
import pandas as pd
import itertools
from scipy.stats import special_ortho_group
from sklearn.metrics import pairwise_distances  # (X, Y=None, metric='euclidean')
import math
from functools import reduce
from scipy.spatial import distance_matrix
import sys

sys.path.append("C:/Users/Alj/CODING/my_libs")
from datapoints import sphere_samples
from scipy.optimize import minimize
import sympy as sp
from sympy import I, exp
from sympy.physics.quantum import TensorProduct

import matplotlib.pyplot as plt
class StateMaker():

    def __init__(self):
        # currently only 3 qbits are supported (or two)
        self.n_qbits = 3
        
    def set_operator(self, generator_args, symbolic_op_matrix):
        self.generator_args = generator_args
        self.symbolic_operator = symbolic_op_matrix
        self.symbolic_final_state = self.symbolic_operator[:,0]
 
        
    def set_default_operator(self):
        n = self.n_qbits
        id2d = sp.Matrix([[1,0],[0,1]]) 
        
        #### part 1 of creating operator 
        # get symbols for the angles defining the y rotations for each qubit
        phi_base_rot = sp.symbols(" ".join(['phi_'+str(i) for i in range(n)]))

        # list of y rotation operators, one per qubit i, depending on angle phi_i
        yrot_per_qubit = [sp.Matrix([[sp.cos(phi_base_rot[i]/2),-sp.sin(phi_base_rot[i]/2)], 
                    [sp.sin(phi_base_rot[i]/2), sp.cos(phi_base_rot[i]/2)]]) for i in range(n)]

        # take the tensor product of all the distinct rotation operator
        base_rot_unitary = reduce(TensorProduct, yrot_per_qubit)
        # show first column of operator, i.e. the image of the ground state
        base_rot_unitary[:,0]

        n_add_rot = 3 # number of additional rotations 
        phi_add_rot = sp.symbols(" ".join(['phi_'+str(i) for i in range(n,n+n_add_rot)]))
        
        ####  part 2 of creating operator: additional y rotations
        add_rot_unitaries = []
        for k in range(n_add_rot):
            yrot_per_qubit = sp.Matrix([[sp.cos(phi_add_rot[k]/2),-sp.sin(phi_add_rot[k]/2)], 
                                        [sp.sin(phi_add_rot[k]/2), sp.cos(phi_add_rot[k]/2)]])     
            add_rot_unitaries.append(reduce(TensorProduct, [yrot_per_qubit]+[id2d]*2))
        #### part 3 of creating operator: Get 3 different permutations
        ## with cirq create required permutations of rows
        c = cirq.Circuit()
        switch_45_gates = [cirq.TOFFOLI.on(cirq.GridQubit(0, 0), cirq.GridQubit(1, 0), cirq.GridQubit(2, 0)),
                    cirq.CNOT.on(cirq.GridQubit(0, 0), cirq.GridQubit(2, 0))]
        c.append(switch_45_gates)
        switch_45 = sp.Matrix(np.real(c.unitary()).astype(int) )

        c = cirq.Circuit()
        switch_4567_gates = [
            cirq.CNOT(cirq.GridQubit(0, 0),cirq.GridQubit(1, 0)),
            cirq.CNOT(cirq.GridQubit(0, 0),cirq.GridQubit(2, 0)),
        ]
        c.append(switch_4567_gates)
        switch_4567 = sp.Matrix(np.real(c.unitary()).astype(int) )
        
        # create a toffoli
        c = cirq.Circuit()
        tofolli_gate = [
            cirq.CCX(cirq.GridQubit(0, 0),cirq.GridQubit(1, 0),cirq.GridQubit(2, 0))
        ] 
        c.append(tofolli_gate)
        toffoli = sp.Matrix(np.real(c.unitary()).astype(int) )

        self.generator_args = phi_base_rot + phi_add_rot

        self.symbolic_operator = (add_rot_unitaries[-1]*switch_45
                                    *add_rot_unitaries[-2]*toffoli
                                    *add_rot_unitaries[-3]*switch_4567 
                                    *base_rot_unitary) 
        # circuit operator applied to the ground state |000> is just the first column,
        # since the ground state is represented by the first standard base vector (1,0,0,0,0,0,0,0) 
        self.symbolic_final_state = self.symbolic_operator[:,0]
        print("WARNING: do not print/show the symbolic operator in notebook, it would make it crash, since too large - just print single column instead")
        return

    # def get_state_function(symbolic_op_matrix):  
    #         """the symbolic final state (i.e. image of ground state under operator) defines a function
    #         from the space of the parameters to the vector space where the final state lives
    #         this function object is returned      
    #         """
    #         generator_args = symbolic_op_matrix.free_symbols
    #         print('arguments of state_generator:', generator_args)
    #         # create a function of the rotation angles to resulting final state
    #         state_function_0 = sp.lambdify(generator_args, symbolic_op_matrix[:,0], 'numpy')
    #         def state_function(angles_list):
    #             return state_function_0(*angles_list).flatten()
    #         return state_function, generator_args
    
    def get_state_function(self):  
        """the symbolic final state (i.e. image of ground state under operator) defines a function
        from the space of the parameters to the vector space where the final state lives
        this function object is returned      
        """
        generator_args = self.symbolic_final_state.free_symbols
        print('arguments of state_generator:', generator_args)
        # create a function of the rotation angles to resulting final state
        state_function_0 = sp.lambdify(self.generator_args, self.symbolic_final_state, 'numpy')
        def state_function(angles_list):
            return state_function_0(*angles_list).flatten()
        return state_function

    def get_circ_of_default_op(self, angles):
        n_qb = self.n_qbits
        q = [cirq.GridQubit(i, 0) for i in range(n_qb)]

        switch_45_gates = [cirq.TOFFOLI.on(cirq.GridQubit(0, 0), cirq.GridQubit(1, 0), cirq.GridQubit(2, 0)),
                cirq.CNOT.on(cirq.GridQubit(0, 0), cirq.GridQubit(2, 0))
        ]
        switch_4567_gates = [
            cirq.CNOT(cirq.GridQubit(0, 0),cirq.GridQubit(1, 0)),
            cirq.CNOT(cirq.GridQubit(0, 0),cirq.GridQubit(2, 0)),
        ]
        tofolli_gate = [
            cirq.CCX(cirq.GridQubit(0, 0),cirq.GridQubit(1, 0),cirq.GridQubit(2, 0))
        ] 
        c = cirq.Circuit()
        c.append( 
                [cirq.ry(angles[i])(q[i]) for i in range(n_qb)]
                + switch_4567_gates
                + [cirq.ry(angles[n_qb+0])(q[0])]
                + tofolli_gate
                + [cirq.ry(angles[n_qb+1])(q[0])]
                + switch_45_gates
                + [cirq.ry(angles[n_qb+2])(q[0])]     
        )
        return c

    def approx_target_state(self, target):

        n_runs = 20
        n_args = len(self.generator_args)
        state_function = self.get_state_function()

        if np.any(target<0):
            print("input target must be non-negative vector")
            return None


        if not math.isclose(np.linalg.norm(target), 1):
            scale = 1/np.linalg.norm(target)
            target = scale*target
            print("target vector was scaled by ", scale, " to be unit vector")
        else:
            scale = 1

        def fit_rotations(target, n_args, n_runs, verbose=False):

            n = int(np.log2(len(target)))
            def objective(phi):
                return np.linalg.norm(state_function(phi)-target)
            objval = 10
            init = np.random.random(n_args)*2*np.pi 
            for i in range(n_runs):
                if verbose: print('.',end='')
                opt_res = minimize(objective,init,method='Powell')   # use Nelder-Mead or Powell
                if objval  > opt_res.fun:
                    curr_opt = opt_res.x
                    objval  = opt_res.fun
                    if verbose: print('>',end='')
                init = curr_opt + np.random.randn(n_args)*1.5  # or use *(0.9**i)
                
            return curr_opt, objval

        angles, objval = fit_rotations(target=target, n_args=n_args, n_runs=50)
        state_approx = state_function(angles)
        assert(math.isclose(objval, np.linalg.norm(state_approx-target))) 
        res = {"arg_angles": angles, 
               "state_approx": state_approx, 
               "target": target, 
               "applied_scale": scale, 
               "objective_value": objval}
        return res

    def plot_gen_image(self, n_samples=int(5e4), random_rotation=False):
        """generate and plot large sample of state generator image

        from a sample on input angles a sample of the image of the state_function is generated
        all 2-dim projections are plotted
        random_rotation: if yes, the the image will be rotated before projecting to allow different perspective
        image of state_function is plotted in red
        for vizual comparison a same-size sample of the non-negative sphere is plotted in blue below
        """
        if random_rotation: # sample a radom rotation matrix
            rotation = special_ortho_group.rvs(2**n_qbits)
            lower_ax_limit = -1.05
        else: # or set to identity 
            rotation = np.diag(np.repeat(1,2**n_qbits))
            lower_ax_limit = -0.05

        n_args = len(self.generator_args)
        args_sampled = np.reshape(np.random.uniform(0,2*np.pi,n_args*n_samples),(n_samples, n_args))
        generator_image = np.apply_along_axis(lambda x: np.abs(self.symbolic_final_state(x)), 1, args_sampled).squeeze()
        #image_norms = np.apply_along_axis(np.linalg.norm, 1, generator_image)
        #print(np.min(image_norms), np.max(image_norms))
        ## sample full non-negative sphere for vizual comparison
        nng_sphere = sphere_samples(n_dim=2**n_qbits, n_samples=n_samples, subset="non-negative")
        # create plot
        proj_coordinates = list(itertools.combinations(range(2**n_qbits),2))
        n_proj = len(proj_coordinates)
        ncols = 7
        nrows = int(np.ceil(n_proj/ncols))
        figsize_factor =12
        fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize= (figsize_factor,figsize_factor*nrows/ncols))
        #fig.tight_layout()
        for i,(j,k) in enumerate(proj_coordinates):
            #TODO: not tick labels except first col and last row
            axes[i//ncols,i%ncols].scatter(nng_sphere.dot(rotation)[:,k], 
                                        nng_sphere.dot(rotation)[:,j], color='b', s=2, alpha=0.5)
            axes[i//ncols,i%ncols].scatter(generator_image.dot(rotation)[:,k], 
                                        generator_image.dot(rotation)[:,j], color='r', s=1.5, alpha=0.1)
            axes[i//ncols,i%ncols].set_title('proj. '+str(j)+', '+str(k))
            axes[i//ncols,i%ncols].set_xlim(lower_ax_limit,1.05)
            axes[i//ncols,i%ncols].set_ylim(lower_ax_limit,1.05)
            if (i%ncols) > 0:
                axes[i//ncols,i%ncols].get_yaxis().set_visible(False)
            if (i//ncols) < (nrows-1):
                axes[i//ncols,i%ncols].get_xaxis().set_visible(False)
    


def yrot_sympy_matrix(radians_symbol):
    return sp.Matrix([[sp.cos(radians_symbol/2),-sp.sin(radians_symbol/2)], 
                                [sp.sin(radians_symbol/2), sp.cos(radians_symbol/2)]]) 

id2d = sp.Matrix([[1,0],[0,1]]) 

def sphere_samples(n_dim, n_samples=1000, subset=None):
    """
    create samples of whole sphere of n_dim dimensions or if
    subset='non-negative', then only of non-negative part """
    mvnormal = np.random.randn(n_samples, n_dim)
    if subset=="non-negative":
        mvnormal = np.abs(mvnormal)   
    return (mvnormal.T*(1/np.linalg.norm(mvnormal,axis=1))).T    

   
            
    # def plot_gen_image(self, n_samples=int(5e4), random_rotation=False):
    #     """generate and plot large sample of state generator image

    #     from a sample on input angles a sample of the image of the state_function is generated
    #     all 2-dim projections are plotted
    #     random_rotation: if yes, the the image will be rotated before projecting to allow different perspective
    #     image of state_function is plotted in red
    #     for vizual comparison a same-size sample of the non-negative sphere is plotted in blue below
    #     """
    #     if random_rotation: # sample a radom rotation matrix
    #         rotation = special_ortho_group.rvs(2**self.n_qbits)
    #     else: # or set to identity 
    #         rotation = np.diag(np.repeat(1,2**self.n_qbits))

    #     n_args = len(self.generator_args)
    #     args_sampled = np.reshape(np.random.uniform(0,2*np.pi,n_args*n_samples),(n_samples, n_args))
    #     generator_image = np.apply_along_axis(lambda x: np.abs(self.state_function(x)), 1, args_sampled).squeeze()
    #     ## sample full non-negative sphere for vizual comparison
    #     nng_sphere = sphere_samples(n_dim=2**self.n_qbits, n_samples=n_samples, subset="non-negative")
    #     # create plot
    #     proj_coordinates = list(itertools.combinations(range(2**self.n_qbits),2))
    #     n_proj = len(proj_coordinates)
    #     ncols = 4
    #     nrows = int(np.ceil(n_proj/ncols))
    #     fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize= (12,12*nrows/ncols))
    #     for i,(j,k) in enumerate(proj_coordinates):
    #         axes[i//ncols,i%ncols].scatter(nng_sphere.dot(rotation)[:,k], 
    #                                     nng_sphere.dot(rotation)[:,j], color='b', s=2, alpha=0.5)
    #         axes[i//ncols,i%ncols].scatter(generator_image.dot(rotation)[:,k], 
    #                                     generator_image.dot(rotation)[:,j], color='r', s=1.5, alpha=0.1)
    #         axes[i//ncols,i%ncols].set_title('dimensions '+str(j)+', '+str(k))
    #         axes[i//ncols,i%ncols].set_xlim(-1.05,1.05)
    #         axes[i//ncols,i%ncols].set_ylim(-1.05,1.05)

            






